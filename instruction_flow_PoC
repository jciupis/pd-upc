L0:      sub  $s4,$s4,1
         mul  $s5,$s4,3
         beqz $s5,   T1
         j    T2
T1:      add  $s5,$s5,$s4
T2:      bgt  $s4, 0, L0

Init vals: $s4 <- 5, $s5 <- 1
1000:L0      sub  $s4,$s4,1
1004		 mul  $s5,$s4,3
1008		 beqz $s5,   T1
100c		 j    T2
1010:T1:   	 add  $s5,$s5,$s4
1014:T2:   	 bgt  $s4, 0, L0

PC = 0ff0
integer s4 = 5
integer s5 = 1

for each loop
		d_is_branch = 1'b0;       // Clear DECODE flag indicating if the instruction was a branch.
		x_predict_res = 1'b0;
		
		d_pc = f_pc;              // DECODE PC is the PC from previous FETCH stage.
		f_pc = f_pc + 4;
case (PC) //And this is the expected execution flow
1000: nothing interesting
1004: nothing interesting
1008:1st
->pass to decode // no more
100c: -> pass to decode
	d_is_branch = 1'b1; //for 1008!!
	->expect d_addr_found 0!
	->expect in_addr_array[0] = 1008
	->the label is known: T1(1010)
	->store 0: 1008 || => 1010 || 01 //start always with weak not-taken prediction-fall through
	entry to replace + 1 (1);
1010: pass to decode

	d_is_branch = 1'b1; //for 100c!!
	->expect d_addr_found 0!
	->expect in_addr_array[1] = 100c
	->the label is known: T2(1014)
	->store 1: 100c || => 1014 || 01 //start always with weak not-taken prediction-fall through
	entry to replace + 1 (2);

1014: pass to decode
	->result from EX(1008)
	x_predict_res = 0
	store 0: 1008 || => 1010 || 00 //decrement the state!

1018: pass to decode (Dummy instruction)
	d_is_branch = 1'b1; //for 1014!!
	->expect d_addr_found 0!
	->expect in_addr_array[2] = 1014
	->the label is known: L0(1000)
	->store 2: 1014 || => 1000 || 01 //start always with weak not-taken prediction-fall through
	entry to replace + 1 (3);
	->jump (j T2) result is ready, the CPU sets PC to 1014
	feedback is TAKEN
	store 1: 100c || => 1014 || 10 
NEW_PC: //assume pipeline flushing/stalls handled by CPU
1014:
	f_addr_found 1!
	f_predict_addr = 1000
	f_predict_valid = 0!! //as our initial state is weak-no
	
->PC 1018
nothing interesting
->PC 101c
nothing interesting
->PC 1020 (here it gets interesting, as the EX has obtained the result of 1014, which is TAKEN, so we mispredicted, thus we have to receive our feedback and adjust)
pass to decode
x_predict_res = 1
->store 2: 1014 || => 1000 || 10
NEW_PC
1000
// nothing interesting
1004
// nothing interesting
1008:
	f_addr_found 1!
	f_predict_addr = 1010
	f_predict_valid = 0!! //This is a correct prediction! Fall through
	
100c:
	f_addr_found 1!
	f_predict_addr = 1014
	f_predict_valid = 1!! //This is a correct prediction! Jump
NEW_PC
1014
	f_addr_found 1!
	f_predict_addr = 1000
	f_predict_valid = 1!! //This is a correct prediction! Jump
NEW_PC
1000
Feedback for operation 1008 available
store 0: 1008 || => 1010 || 00
1004
Feedback for operation 100c available
store 1: 100c || => 1014 || 11 (increment!)
1008: the same... plus feedback for 1014
100c: predict jump
1014: predict jump
1000:feedback for 1008
1004 : feedback for 100c...

//Moral: we need to know somehow what feedback goes to what entry
